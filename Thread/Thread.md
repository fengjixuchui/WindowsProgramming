# 线程基础
多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。
每次初始化进程时，系统都会创建一个主线程。


## 线程组成部分：
* 内核对象：操作系统用它来管理线程、存放线程统计信息
* 线程栈：用于维护线程执行时所需的所有函数参数和局部变量

## 为什么要使用多线程
如前面所述，进程初始化时，系统会创建一个主线程。如果进程需要执行多个任务，如发送、打印等。  
如果只有一个线程，这些任务都需要按顺序执行，即前面的执行完后面的才能执行。  
假设某个任务持续的时间较长，界面无法实时更新，应用程序就好像失去响应一样。  
这个时候就需要使用多线程。多个任务由不同的线程去执行，不同线程各自占用CPU一段时间，即使线程任务还没完成，也会让出CPU时间给其它线程有机会去执行。  
这样，在用户角度看来，用户界面就永远保持更新，其它任务也在同步运行，提升了软件的友好程度。

## 多核心CPU
如果我计算机有两个CPU，而且应用程序有两个线程，那么两个CPU都会很忙。而结果就是：只需花一个任务的时间，两个任务都可以完成。
如果计算机只有一个CPU，而且应用程序有两个线程，那么两个CPU都会很忙。而结果就是：两个任务在各自的时间片内去执行。
关于线程的时间片会配，后面会说明。

## 进程和线程
进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。  
进程就是正在运行的程序  
Windows能同时运行多个进程，如运行网易云音乐的同时，又能运行QQ。  

进程有三种状态
* 运行态：正在CPU中运行
* 就绪态：运行准备就绪，但其它进程正在运行，所以只能等待（等待分配时间片）
* 阻塞态：由于进程等待某种条件（如I/O操作或进程同步），在条件满足之前无法继续执行。该事件发生前即使把处理器资源分配给该进程，也无法运行。
  
![Process State](ProcessState.jpg)

每个进程中至少有一个线程（主线程）。线程是程序执行的最小执行单位，是操作系统分配CPU时间的最小实体。  
线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。  
*注意：在某些情况下，可能由于线程未正常退出，而导致程序未完全退出，最常见的就是窗体已经关闭了，而进程在任务管理器还可以看到*

## 使用多线程的情况 
* 程序中各任务相对独立，如更新界面状态信息、提供服务功能等
* 某些任务耗时较多，如下载操作，打印操作
* ...  

## 线程调度
进程中有了多个线程后，就要管理这些线程如何去占用CPU，这就是线程调度。线程调度通常由操作系统来安装，不同的操作系统其调度方法不同。  
Windows操作系统是一个优先级驱动、抢占式操作系统，也就是线程具有优先级。具有高优先级的可运行的线程总是先运行。
由于这种抢占式的调度，一个正在运行的线程可能在未完成其时间片时，被更高优先级的线程所抢占，甚至一个线程会在未开始其时间片前就被抢占了，而要等待下一次被选择运行。  

调度线程是在内核中进行的。当发生下面这些事件时，将触发内核进行线程调度：
* 线程的状态变成就绪状态。例如：一个新创建的线程，或者从等待状态释放出来的线程。
* 线程的时间片结束而离开运行状态，它可能运行结束了，或者进入等待状态
* 线程的优先级改变了
* 出现了其它更高优先级的线程

每个线程都被赋予了一个优先级，优先级的取值范围从0（最低）到31（最高）。


线程最初的优先级由进程的优先级类别和线程所处的优先级层次决定。

进程的优先级可以分为以下几类：

优先级|说明
:--:|:--:
IDLE_PRIORITY_CLASS(0x00000040)|空闲优先级类别，该类别进程中的线程只在系统处于空闲的时候才运行，并且这些线程会被更高优先级进程中的线程所抢占。如：屏幕保护程序
BELOW_NORMAL_PRIORITY_CLASS(0x00004000)|该类别比空闲优先级类别高，但比正常优先级类别低
NORMAL_PRIORITY_CLASS(0x00000020)|正常优先级类别，是进程默认的优先级类别
ABOVE_NORMAL_PRIORITY_CLASS(0x00008000)|比正常优先级类别高，但低于高优先级类别
HIGH_PRIORITY_CLASS(0x00000080)|高优先级类别。拥有该类别的进程通常要完成实时性的任务，如必须要立即执行的任务。该进程中的线程可以抢占正常优先级类别进程和空闲优先级类别进程中的线程。使用该优先级时要慎重，因为高优先级类别的进程几乎可以使用所有CPU能提供的时间，如果该优先级的进程长时间运行，那么其它线程很可能一直得不到处理器时间。
REALTIME_PRIORITY_CLASS(0x00000100)|实时优先级类别，这是最高的优先级类别。拥有该类别进程的线程能抢占其它所有进程中的线程，包括正在完成重要工作的操作系统进程。对于该优先级，应该尽量不去使用，因为它会中断操作系统的工作，只有在直接和硬件打交道或任务执行时间非常短时才适合使用该优先级类别

在进程的每个优先级别中，线程的优先级层次又有以下划分
优先级|符号常数
:--:|:--:
idle|THREAD_PRIORITY_IDLE
lowest|THREAD_PRIORITY_LOWEST
below normal|THREAD_PRIORITY_BELOW_NORMAL
normal|THREAD_PRIORITY_NORMAL
above normal|THREAD_PRIORITY_ABOVE_NORMAL
highest|THREAD_PRIORITY_HIGHEST
time-critical|THREAD_PRIORITY_TIME_CRITICAL

所有线程在创建的时候都属于THREAD_PRIORITY_NORMAL优先级层次，如果要修改优先级层次，可以  
在调用CreateThread时传入CREATE_SUSPENDED标志  
再调用函数SetThreadPriority修改线程优先级层次
接着调用ResumeThread让线程变为可调度

有了进程和线程的优先级层次，就可以确定一个线程的基础优先级了，如下：
![Priority Table](priority_table.png)
